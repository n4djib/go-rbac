== TODOs ==
			- make it a library
			- seperate engines to avoid installing goja or otto packages if not needed
- optimizations
	what if we change the data into graph at init
		would that be faster?
	set the data as maps not slices
		would that be faster?
		the slice length is short????
		Lookup Operations:
			Maps: O(1) average case for lookups by key - very fast
			Slices: O(n) for searching unless sorted (then O(log n) with binary search)
	what if we use pointers (copy by reference)
- a better optimization
	we don't evaluate the rule unless
		the rule leads to the role
	traverse the tree as if the rules are all true without running them
	and check if the user has the required role
	if he has the required role
	we traverse the tree
- can we use Goroutines to speed things up?
	maybe in running the rules
- change the JS (library) like you did with the GO version
	changed how it checks the setting of Roles and Permissions and RolePermissions
- IsAllowed() result should return a message indicating the reason for unauthorized or authorized
- are the rules able to run in both GO and JS
	when i am using then in a frontend & backend app
- add a flag to enable debug mode
	to debug the engine and the rbac library and watch the decision making process
- rules for Roles
	role: manager
		but the rule says manager of (group)
		maybe you are a manager if a condition applies
			like if your manager is absent
- how to version the libraries
	by using git tags
		i don't know how the users can decide which version to use

- Memoize the IsAllowed() and engine RunRule()
	proble is that rules apply to changig data
		not really, the principal and resource are part of the Memoize call
- pre calculate IsAllowed results
- check if the fields in the rule are all present in the principal and resource
	maybe this is too much overhead and we should leave it up to the developer
			- it seems like the tests in rbac_integration_test are installing all the engines
				which is exactly what i was trying to avoid
				ANSWER: it's not a problem, they are downloaded for the test only
					and will not be included in the final binary
- in SetRbac() or any func that can have many errors
	return a slice of errors []error 
	or
		called error accumulator
		6. Error Accumulator
			type ErrorCollector struct { errors []error }
			func (ec *ErrorCollector) Add(err error) {
				if err != nil {
					ec.errors = append(ec.errors, err)
				}
			}
			func (ec *ErrorCollector) Error() error {
				if len(ec.errors) == 0 { return nil }
				return errors.Join(ec.errors...)
			}
			// Usage
			func process() error {
				var errs ErrorCollector
				errs.Add(step1())
				errs.Add(step2())
				errs.Add(step3())
				return errs.Error()
			}
- how to test in both languages at the same time
	maybe integration test where the JS tries the GO backend
	SOLUTION: write the tests cases in JSON format
		convert them to the GO format and use them in GO tests
		use the same JSON test cases in JS tests
- set the Principal and Resource Validation method in the New() Engine func
- name the test files blackbox and whitebox not integration
- 
- create a UI relations visualizer and editor
	abstract enaugh
- create a CLI tool for the library (bubble tea + ssh)
	to create roles and Permissions and RolePermissions
- add license file
- write a README.md file
	use readme.so
- add doc.go file to the library package for godoc support
- provide a database schema in SQL (to aid users in database creation)
	maybe just in the readme.md file
- Use Predefined Errors
	For the best approach, define your errors as package variables:
	var (
		ErrInvalidFormat = errors.New("invalid input format")
		ErrNotFound      = errors.New("item not found")
	)

- 
- 
- 


== DONE ==
	- when creating New rbac, at first pass a nil as an empty implementation of the interface
		and if it is empty don't use rules (and don't accept them in SetRbac)
	- add testing
	- need to improve error handling
	- you can add error state in struct
		why do this??
	- write tests for the engines
	- try to use RunRule (check rule) from the engine 
		to allow the user to test if the engine can evaluate the rule




== Run & Testing ==
go-rbac\example\basic> go run .
go-rbac\example>go run .\basic\ .
	must run from basic where there a mod file

go-rbac\engine> go test -v -coverpkg=./... -coverprofile=c.out .
go-rbac\engine> go tool cover -html=c.out

go-rbac\rbac> go test -coverprofile=c.out .
go-rbac\rbac> go tool cover -html=c.out



== GIT ==
= tags:
git tag rbac/v0.1.0
git tag engine/fastergoga/v0.1.0
git tag engine/fasterotto/v0.1.0
git tag engine/simpleotto/v0.1.0
git push --tags


git tag rbac/v0.2.0
git tag engine/fastergoga/v0.2.0
git tag engine/fasterotto/v0.2.0
git tag engine/simpleotto/v0.2.0
git push --tags

git push --tags --force
